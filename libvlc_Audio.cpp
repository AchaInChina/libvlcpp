/*****************************************************************************
 * libvlc_Audio.cpp: Audio implementation
 *****************************************************************************
 * Copyright Â© 2014 the VideoLAN team
 *
 * Authors: Alexey Sokolov <alexey@alexeysokolov.co.cc>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
 *****************************************************************************/

/* This file is autogenerated */


#include <vlc.hpp>

namespace VLC {


Audio::Audio(libvlc_media_player_t* obj) 
{
    if (!obj) 
    {
        throw Exception("Can't construct Audio");
    }
    m_obj = obj;
}

Audio::Audio(const Audio& another) 
{
    m_obj = another.m_obj;
    retain();
}

const Audio& Audio::operator=(const Audio& another) 
{
    if (this == &another) 
    {
        return *this;
    }
    release();
    m_obj = another.m_obj;
    retain();
    return *this;
}

bool Audio::operator==(const Audio& another) const 
{
    return m_obj == another.m_obj;
}

Audio::~Audio() 
{
    release();
}


void Audio::setCallbacks(libvlc_audio_play_cb play, libvlc_audio_pause_cb pause, libvlc_audio_resume_cb resume, libvlc_audio_flush_cb flush, libvlc_audio_drain_cb drain, void * opaque) 
{
    libvlc_audio_set_callbacks(m_obj, play, pause, resume, flush, drain, opaque);
}

void Audio::setVolumeCallback(libvlc_audio_set_volume_cb set_volume) 
{
    libvlc_audio_set_volume_callback(m_obj, set_volume);
}

void Audio::setFormatCallbacks(libvlc_audio_setup_cb setup, libvlc_audio_cleanup_cb cleanup) 
{
    libvlc_audio_set_format_callbacks(m_obj, setup, cleanup);
}

void Audio::setFormat(const std::string& format, unsigned rate, unsigned channels) 
{
    libvlc_audio_set_format(m_obj, format.c_str(), rate, channels);
}

int Audio::outputSet(const std::string& psz_name) 
{
    int c_result = libvlc_audio_output_set(m_obj, psz_name.c_str());
    int result = c_result;
    return result;
}

libvlc_audio_output_device_t * Audio::outputDeviceEnum() 
{
    libvlc_audio_output_device_t * c_result = libvlc_audio_output_device_enum(m_obj);
    libvlc_audio_output_device_t * result = c_result;
    return result;
}

void Audio::outputDeviceSet(const std::string& module, const std::string& device_id) 
{
    libvlc_audio_output_device_set(m_obj, module.c_str(), device_id.c_str());
}

void Audio::toggleMute() 
{
    libvlc_audio_toggle_mute(m_obj);
}

int Audio::mute() 
{
    int c_result = libvlc_audio_get_mute(m_obj);
    int result = c_result;
    return result;
}

void Audio::setMute(int status) 
{
    libvlc_audio_set_mute(m_obj, status);
}

int Audio::volume() 
{
    int c_result = libvlc_audio_get_volume(m_obj);
    int result = c_result;
    return result;
}

int Audio::setVolume(int i_volume) 
{
    int c_result = libvlc_audio_set_volume(m_obj, i_volume);
    int result = c_result;
    return result;
}

int Audio::trackCount() 
{
    int c_result = libvlc_audio_get_track_count(m_obj);
    int result = c_result;
    return result;
}

std::list<TrackDescription> Audio::trackDescription() 
{
    libvlc_track_description_t * c_result = libvlc_audio_get_track_description(m_obj);
    std::list<TrackDescription> result = TrackDescription::makeList(c_result);
    libvlc_track_description_list_release(c_result);
    return result;
}

int Audio::track() 
{
    int c_result = libvlc_audio_get_track(m_obj);
    int result = c_result;
    return result;
}

int Audio::setTrack(int i_track) 
{
    int c_result = libvlc_audio_set_track(m_obj, i_track);
    int result = c_result;
    return result;
}

int Audio::channel() 
{
    int c_result = libvlc_audio_get_channel(m_obj);
    int result = c_result;
    return result;
}

int Audio::setChannel(int channel) 
{
    int c_result = libvlc_audio_set_channel(m_obj, channel);
    int result = c_result;
    return result;
}

int64_t Audio::delay() 
{
    int64_t c_result = libvlc_audio_get_delay(m_obj);
    int64_t result = c_result;
    return result;
}

int Audio::setDelay(int64_t i_delay) 
{
    int c_result = libvlc_audio_set_delay(m_obj, i_delay);
    int result = c_result;
    return result;
}

void Audio::retain() {
    libvlc_media_player_retain(m_obj);
}


void Audio::release() {
    libvlc_media_player_release(m_obj);
}


} // namespace VLC

