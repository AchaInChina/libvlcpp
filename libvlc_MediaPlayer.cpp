/*****************************************************************************
 * libvlc_MediaPlayer.cpp: MediaPlayer implementation
 *****************************************************************************
 * Copyright Â© 2014 the VideoLAN team
 *
 * Authors: Alexey Sokolov <alexey@alexeysokolov.co.cc>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
 *****************************************************************************/

/* This file is autogenerated */


#include <vlc.hpp>

namespace VLC {


MediaPlayer::MediaPlayer(libvlc_media_player_t* obj) 
{
    if (!obj) 
    {
        throw Exception("Can't construct MediaPlayer");
    }
    m_obj = obj;
}

MediaPlayer::MediaPlayer(const MediaPlayer& another) 
{
    m_obj = another.m_obj;
    retain();
}

const MediaPlayer& MediaPlayer::operator=(const MediaPlayer& another) 
{
    if (this == &another) 
    {
        return *this;
    }
    release();
    m_obj = another.m_obj;
    retain();
    return *this;
}

bool MediaPlayer::operator==(const MediaPlayer& another) const 
{
    return m_obj == another.m_obj;
}

MediaPlayer::~MediaPlayer() 
{
    release();
}


MediaPlayer::MediaPlayer(Instance & p_libvlc_instance) 
{
    m_obj = libvlc_media_player_new(p_libvlc_instance.get_c_object());
    if (!m_obj) 
    {
        throw Exception("Can't construct MediaPlayer");
    }
}

MediaPlayer::MediaPlayer(Media & p_md) 
{
    m_obj = libvlc_media_player_new_from_media(p_md.get_c_object());
    if (!m_obj) 
    {
        throw Exception("Can't construct MediaPlayer");
    }
}

Audio MediaPlayer::audio() {
    retain();
    return Audio(m_obj);
}


Video MediaPlayer::video() {
    retain();
    return Video(m_obj);
}


void MediaPlayer::setMedia(Media & p_md) 
{
    libvlc_media_player_set_media(m_obj, p_md.get_c_object());
}

Media MediaPlayer::media() 
{
    libvlc_media_t * c_result = libvlc_media_player_get_media(m_obj);
    Media result = c_result;
    return result;
}

libvlc_event_manager_t * MediaPlayer::eventManager() 
{
    libvlc_event_manager_t * c_result = libvlc_media_player_event_manager(m_obj);
    libvlc_event_manager_t * result = c_result;
    return result;
}

bool MediaPlayer::isPlaying() 
{
    int c_result = libvlc_media_player_is_playing(m_obj);
    bool result = c_result;
    return result;
}

int MediaPlayer::play() 
{
    int c_result = libvlc_media_player_play(m_obj);
    int result = c_result;
    return result;
}

void MediaPlayer::setPause(int do_pause) 
{
    libvlc_media_player_set_pause(m_obj, do_pause);
}

void MediaPlayer::pause() 
{
    libvlc_media_player_pause(m_obj);
}

void MediaPlayer::stop() 
{
    libvlc_media_player_stop(m_obj);
}

void MediaPlayer::setNsobject(void * drawable) 
{
    libvlc_media_player_set_nsobject(m_obj, drawable);
}

void * MediaPlayer::nsobject() 
{
    void * c_result = libvlc_media_player_get_nsobject(m_obj);
    void * result = c_result;
    return result;
}

void MediaPlayer::setAgl(uint32_t drawable) 
{
    libvlc_media_player_set_agl(m_obj, drawable);
}

uint32_t MediaPlayer::agl() 
{
    uint32_t c_result = libvlc_media_player_get_agl(m_obj);
    uint32_t result = c_result;
    return result;
}

void MediaPlayer::setXwindow(uint32_t drawable) 
{
    libvlc_media_player_set_xwindow(m_obj, drawable);
}

uint32_t MediaPlayer::xwindow() 
{
    uint32_t c_result = libvlc_media_player_get_xwindow(m_obj);
    uint32_t result = c_result;
    return result;
}

void MediaPlayer::setHwnd(void * drawable) 
{
    libvlc_media_player_set_hwnd(m_obj, drawable);
}

void * MediaPlayer::hwnd() 
{
    void * c_result = libvlc_media_player_get_hwnd(m_obj);
    void * result = c_result;
    return result;
}

libvlc_time_t MediaPlayer::length() 
{
    libvlc_time_t c_result = libvlc_media_player_get_length(m_obj);
    libvlc_time_t result = c_result;
    return result;
}

libvlc_time_t MediaPlayer::time() 
{
    libvlc_time_t c_result = libvlc_media_player_get_time(m_obj);
    libvlc_time_t result = c_result;
    return result;
}

void MediaPlayer::setTime(libvlc_time_t i_time) 
{
    libvlc_media_player_set_time(m_obj, i_time);
}

float MediaPlayer::position() 
{
    float c_result = libvlc_media_player_get_position(m_obj);
    float result = c_result;
    return result;
}

void MediaPlayer::setPosition(float f_pos) 
{
    libvlc_media_player_set_position(m_obj, f_pos);
}

void MediaPlayer::setChapter(int i_chapter) 
{
    libvlc_media_player_set_chapter(m_obj, i_chapter);
}

int MediaPlayer::chapter() 
{
    int c_result = libvlc_media_player_get_chapter(m_obj);
    int result = c_result;
    return result;
}

int MediaPlayer::chapterCount() 
{
    int c_result = libvlc_media_player_get_chapter_count(m_obj);
    int result = c_result;
    return result;
}

bool MediaPlayer::willPlay() 
{
    int c_result = libvlc_media_player_will_play(m_obj);
    bool result = c_result;
    return result;
}

int MediaPlayer::chapterCountForTitle(int i_title) 
{
    int c_result = libvlc_media_player_get_chapter_count_for_title(m_obj, i_title);
    int result = c_result;
    return result;
}

void MediaPlayer::setTitle(int i_title) 
{
    libvlc_media_player_set_title(m_obj, i_title);
}

int MediaPlayer::title() 
{
    int c_result = libvlc_media_player_get_title(m_obj);
    int result = c_result;
    return result;
}

int MediaPlayer::titleCount() 
{
    int c_result = libvlc_media_player_get_title_count(m_obj);
    int result = c_result;
    return result;
}

void MediaPlayer::previousChapter() 
{
    libvlc_media_player_previous_chapter(m_obj);
}

void MediaPlayer::nextChapter() 
{
    libvlc_media_player_next_chapter(m_obj);
}

float MediaPlayer::rate() 
{
    float c_result = libvlc_media_player_get_rate(m_obj);
    float result = c_result;
    return result;
}

int MediaPlayer::setRate(float rate) 
{
    int c_result = libvlc_media_player_set_rate(m_obj, rate);
    int result = c_result;
    return result;
}

libvlc_state_t MediaPlayer::state() 
{
    libvlc_state_t c_result = libvlc_media_player_get_state(m_obj);
    libvlc_state_t result = c_result;
    return result;
}

float MediaPlayer::fps() 
{
    float c_result = libvlc_media_player_get_fps(m_obj);
    float result = c_result;
    return result;
}

unsigned MediaPlayer::hasVout() 
{
    unsigned c_result = libvlc_media_player_has_vout(m_obj);
    unsigned result = c_result;
    return result;
}

bool MediaPlayer::isSeekable() 
{
    int c_result = libvlc_media_player_is_seekable(m_obj);
    bool result = c_result;
    return result;
}

bool MediaPlayer::canPause() 
{
    int c_result = libvlc_media_player_can_pause(m_obj);
    bool result = c_result;
    return result;
}

bool MediaPlayer::programScrambled() 
{
    int c_result = libvlc_media_player_program_scrambled(m_obj);
    bool result = c_result;
    return result;
}

void MediaPlayer::nextFrame() 
{
    libvlc_media_player_next_frame(m_obj);
}

void MediaPlayer::navigate(unsigned navigate) 
{
    libvlc_media_player_navigate(m_obj, navigate);
}

void MediaPlayer::setVideoTitleDisplay(libvlc_position_t position, unsigned int timeout) 
{
    libvlc_media_player_set_video_title_display(m_obj, position, timeout);
}

void MediaPlayer::toggleFullscreen() 
{
    libvlc_toggle_fullscreen(m_obj);
}

void MediaPlayer::setFullscreen(int b_fullscreen) 
{
    libvlc_set_fullscreen(m_obj, b_fullscreen);
}

bool MediaPlayer::fullscreen() 
{
    int c_result = libvlc_get_fullscreen(m_obj);
    bool result = c_result;
    return result;
}

void MediaPlayer::toggleTeletext() 
{
    libvlc_toggle_teletext(m_obj);
}

int MediaPlayer::setEqualizer(libvlc_equalizer_t * p_equalizer) 
{
    int c_result = libvlc_media_player_set_equalizer(m_obj, p_equalizer);
    int result = c_result;
    return result;
}

void MediaPlayer::release() 
{
    libvlc_media_player_release(m_obj);
}

void MediaPlayer::retain() 
{
    libvlc_media_player_retain(m_obj);
}

} // namespace VLC

