/*****************************************************************************
 * libvlc_MediaPlayer.hpp: MediaPlayer API
 *****************************************************************************
 * Copyright Â© 2014 the VideoLAN team
 *
 * Authors: Alexey Sokolov <alexey@alexeysokolov.co.cc>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
 *****************************************************************************/

/* This file is autogenerated */



#ifndef LIBVLC_CXX_MEDIAPLAYER_H
#define LIBVLC_CXX_MEDIAPLAYER_H

#include <libvlc_common.hpp>

namespace VLC 
{


class MediaPlayer 
{
public:
    /**
     * Copy libvlc_media_player_t from another to new MediaPlayer object.
     * \param another existing MediaPlayer
     */
    MediaPlayer(const MediaPlayer& another);

    /**
     * Copy libvlc_media_player_t from another MediaPlayer
     * to this MediaPlayer
     * \param another existing MediaPlayer
     */
    const MediaPlayer& operator=(const MediaPlayer& another);

    /**
     * Check if 2 MediaPlayer objects contain the same libvlc_media_player_t.
     * \param another another MediaPlayer
     * \return true if they contain the same libvlc_media_player_t
     */
    bool operator==(const MediaPlayer& another) const;

    ~MediaPlayer();

    // libvlc_media_player_new
    /**
     * Create an empty Media Player object
     *
     * \param p_libvlc_instance  the libvlc instance in which the Media
     * Player should be created.
     */
    MediaPlayer(Instance & p_libvlc_instance);

    // libvlc_media_player_new_from_media
    /**
     * Create a Media Player object from a Media
     *
     * \param p_md  the media. Afterwards the p_md can be safely destroyed.
     */
    MediaPlayer(Media & p_md);

    /**
     * Get Audio accessor of this MediaPlayer.
     */
    Audio audio();

    /**
     * Get Video accessor of this MediaPlayer.
     */
    Video video();

    /**
     * Set the media that will be used by the media_player. If any, previous
     * md will be released.
     *
     * \param p_md  the Media. Afterwards the p_md can be safely destroyed.
     */
    void setMedia(Media & p_md);

    /**
     * Get the media used by the media_player.
     *
     * \return the media associated with p_mi, or NULL if no media is
     * associated
     */
    Media media();

    /**
     * Get the Event Manager from which the media player send event.
     *
     * \return the event manager associated with p_mi
     */
    libvlc_event_manager_t * eventManager();

    /**
     * is_playing
     *
     * \return 1 if the media player is playing, 0 otherwise
     */
    bool isPlaying();

    /**
     * Play
     *
     * \return 0 if playback started (and was already started), or -1 on
     * error.
     */
    int play();

    /**
     * Pause or resume (no effect if there is no media)
     *
     * \param do_pause  play/resume if zero, pause if non-zero
     *
     * \version LibVLC 1.1.1 or later
     */
    void setPause(int do_pause);

    /**
     * Toggle pause (no effect if there is no media)
     */
    void pause();

    /**
     * Stop (no effect if there is no media)
     */
    void stop();

    /**
     * Set the NSView handler where the media player should render its video
     * output.
     *
     * Use the vout called "macosx".
     *
     * The drawable is an NSObject that follow the
     * VLCOpenGLVideoViewEmbedding protocol:
     *
     * @protocol VLCOpenGLVideoViewEmbedding <NSObject>
     *
     * Or it can be an NSView object.
     *
     * If you want to use it along with Qt4 see the QMacCocoaViewContainer.
     * Then the following code should work:  { NSView *video = [[NSView
     * alloc] init]; QMacCocoaViewContainer *container = new
     * QMacCocoaViewContainer(video, parent);
     * libvlc_media_player_set_nsobject(mp, video); [video release]; }
     *
     * You can find a live example in VLCVideoView in VLCKit.framework.
     *
     * \param drawable  the drawable that is either an NSView or an object
     * following the VLCOpenGLVideoViewEmbedding protocol.
     */
    void setNsobject(void * drawable);

    /**
     * Get the NSView handler previously set with MediaPlayer::setNsobject()
     * .
     *
     * \return the NSView handler or 0 if none where set
     */
    void * nsobject();

    /**
     * Set the agl handler where the media player should render its video
     * output.
     *
     * \param drawable  the agl handler
     */
    void setAgl(uint32_t drawable);

    /**
     * Get the agl handler previously set with MediaPlayer::setAgl() .
     *
     * \return the agl handler or 0 if none where set
     */
    uint32_t agl();

    /**
     * Set an X Window System drawable where the media player should render
     * its video output. If LibVLC was built without X11 output support, then
     * this has no effects.
     *
     * The specified identifier must correspond to an existing Input/Output
     * class X11 window. Pixmaps are supported. The caller shall ensure that
     * the X11 server is the same as the one the VLC instance has been
     * configured with. This function must be called before video playback is
     * started; otherwise it will only take effect after playback stop and
     * restart.
     *
     * \param drawable  the ID of the X window
     */
    void setXwindow(uint32_t drawable);

    /**
     * Get the X Window System window identifier previously set with
     * MediaPlayer::setXwindow() . Note that this will return the identifier
     * even if VLC is not currently using it (for instance if it is playing
     * an audio-only input).
     *
     * \return an X window ID, or 0 if none where set.
     */
    uint32_t xwindow();

    /**
     * Set a Win32/Win64 API window handle (HWND) where the media player
     * should render its video output. If LibVLC was built without
     * Win32/Win64 API output support, then this has no effects.
     *
     * \param drawable  windows handle of the drawable
     */
    void setHwnd(void * drawable);

    /**
     * Get the Windows API window handle (HWND) previously set with
     * MediaPlayer::setHwnd() . The handle will be returned even if LibVLC is
     * not currently outputting any video to it.
     *
     * \return a window handle or NULL if there are none.
     */
    void * hwnd();

    /**
     * Get the current movie length (in ms).
     *
     * \return the movie length (in ms), or -1 if there is no media.
     */
    libvlc_time_t length();

    /**
     * Get the current movie time (in ms).
     *
     * \return the movie time (in ms), or -1 if there is no media.
     */
    libvlc_time_t time();

    /**
     * Set the movie time (in ms). This has no effect if no media is being
     * played. Not all formats and protocols support this.
     *
     * \param i_time  the movie time (in ms).
     */
    void setTime(libvlc_time_t i_time);

    /**
     * Get movie position as percentage between 0.0 and 1.0.
     *
     * \return movie position, or -1. in case of error
     */
    float position();

    /**
     * Set movie position as percentage between 0.0 and 1.0. This has no
     * effect if playback is not enabled. This might not work depending on
     * the underlying input format and protocol.
     *
     * \param f_pos  the position
     */
    void setPosition(float f_pos);

    /**
     * Set movie chapter (if applicable).
     *
     * \param i_chapter  chapter number to play
     */
    void setChapter(int i_chapter);

    /**
     * Get movie chapter.
     *
     * \return chapter number currently playing, or -1 if there is no media.
     */
    int chapter();

    /**
     * Get movie chapter count
     *
     * \return number of chapters in movie, or -1.
     */
    int chapterCount();

    /**
     * Is the player able to play
     *
     * \return boolean
     */
    bool willPlay();

    /**
     * Get title chapter count
     *
     * \param i_title  title
     *
     * \return number of chapters in title, or -1
     */
    int chapterCountForTitle(int i_title);

    /**
     * Set movie title
     *
     * \param i_title  title number to play
     */
    void setTitle(int i_title);

    /**
     * Get movie title
     *
     * \return title number currently playing, or -1
     */
    int title();

    /**
     * Get movie title count
     *
     * \return title number count, or -1
     */
    int titleCount();

    /**
     * Set previous chapter (if applicable)
     */
    void previousChapter();

    /**
     * Set next chapter (if applicable)
     */
    void nextChapter();

    /**
     * Get the requested movie play rate.
     *
     * \warning Depending on the underlying media, the requested rate may be
     * different from the real playback rate.
     *
     * \return movie play rate
     */
    float rate();

    /**
     * Set movie play rate
     *
     * \param rate  movie play rate to set
     *
     * \return -1 if an error was detected, 0 otherwise (but even then, it
     * might not actually work depending on the underlying media protocol)
     */
    int setRate(float rate);

    /**
     * Get current movie state
     *
     * \return the current state of the media player (playing, paused, ...)
     *
     * \see libvlc_state_t
     */
    libvlc_state_t state();

    /**
     * Get movie fps rate
     *
     * \return frames per second (fps) for this playing movie, or 0 if
     * unspecified
     */
    float fps();

    /**
     * end bug How many video outputs does this media player have?
     *
     * \return the number of video outputs
     */
    unsigned hasVout();

    /**
     * Is this media player seekable?
     *
     * \return true if the media player can seek
     */
    bool isSeekable();

    /**
     * Can this media player be paused?
     *
     * \return true if the media player can pause
     */
    bool canPause();

    /**
     * Check if the current program is scrambled
     *
     * \return true if the current program is scrambled
     *
     * \version LibVLC 2.2.0 or later
     */
    bool programScrambled();

    /**
     * Display the next frame (if supported)
     */
    void nextFrame();

    /**
     * Navigate through DVD Menu
     *
     * \param navigate  the Navigation mode
     *
     * \version libVLC 2.0.0 or later
     */
    void navigate(unsigned navigate);

    /**
     * Set if, and how, the video title will be shown when media is played.
     *
     * \param position  position at which to display the title, or
     * libvlc_position_disable to prevent the title from being displayed
     *
     * \param timeout  title display timeout in milliseconds (ignored if
     * libvlc_position_disable)
     *
     * \version libVLC 2.1.0 or later
     */
    void setVideoTitleDisplay(libvlc_position_t position, unsigned int timeout);

    /**
     * Toggle fullscreen status on non-embedded video outputs.
     *
     * \warning The same limitations applies to this function as to
     * MediaPlayer::setFullscreen() .
     */
    void toggleFullscreen();

    /**
     * Enable or disable fullscreen.
     *
     * \warning With most window managers, only a top-level windows can be in
     * full-screen mode. Hence, this function will not operate properly if
     * MediaPlayer::setXwindow() was used to embed the video in a non-top-
     * level window. In that case, the embedding window must be reparented to
     * the root window fullscreen mode is enabled. You will want to reparent
     * it back to its normal parent when disabling fullscreen.
     *
     * \param b_fullscreen  boolean for fullscreen status
     */
    void setFullscreen(int b_fullscreen);

    /**
     * Get current fullscreen status.
     *
     * \return the fullscreen status (boolean)
     */
    bool fullscreen();

    /**
     * Toggle teletext transparent status on video output.
     */
    void toggleTeletext();

    /**
     * Apply new equalizer settings to a media player.
     *
     * The equalizer is first created by invoking
     * libvlc_audio_equalizer_new() or
     * libvlc_audio_equalizer_new_from_preset() .
     *
     * It is possible to apply new equalizer settings to a media player
     * whether the media player is currently playing media or not.
     *
     * Invoking this method will immediately apply the new equalizer settings
     * to the audio output of the currently playing media if there is any.
     *
     * If there is no currently playing media, the new equalizer settings
     * will be applied later if and when new media is played.
     *
     * Equalizer settings will automatically be applied to subsequently
     * played media.
     *
     * To disable the equalizer for a media player invoke this method passing
     * NULL for the p_equalizer parameter.
     *
     * The media player does not keep a reference to the supplied equalizer
     * so it is safe for an application to release the equalizer reference
     * any time after this method returns.
     *
     * \param p_equalizer  opaque equalizer handle, or NULL to disable the
     * equalizer for this media player
     *
     * \return zero on success, -1 on error
     *
     * \version LibVLC 2.2.0 or later
     */
    int setEqualizer(libvlc_equalizer_t * p_equalizer);

private:
    /**
     * Release a media_player after use Decrement the reference count of a
     * media player object. If the reference count is 0, then
     * MediaPlayer::release() will release the media player object. If the
     * media player object has been released, then it should not be used
     * again.
     */
    void release();

    /**
     * Retain a reference to a media player object. Use
     * MediaPlayer::release() to decrement reference count.
     */
    void retain();


    libvlc_media_player_t* m_obj;
};

} // namespace VLC

#endif

