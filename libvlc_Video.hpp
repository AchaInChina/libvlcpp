/*****************************************************************************
 * libvlc_Video.hpp: Video API
 *****************************************************************************
 * Copyright Â© 2014 the VideoLAN team
 *
 * Authors: Alexey Sokolov <alexey@alexeysokolov.co.cc>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
 *****************************************************************************/

/* This file is autogenerated */



#ifndef LIBVLC_CXX_VIDEO_H
#define LIBVLC_CXX_VIDEO_H

#include <libvlc_common.hpp>

namespace VLC 
{


class Video 
{
public:
    /**
     * Copy libvlc_media_player_t from another to new Video object.
     * \param another existing Video
     */
    Video(const Video& another);

    /**
     * Copy libvlc_media_player_t from another Video
     * to this Video
     * \param another existing Video
     */
    const Video& operator=(const Video& another);

    /**
     * Check if 2 Video objects contain the same libvlc_media_player_t.
     * \param another another Video
     * \return true if they contain the same libvlc_media_player_t
     */
    bool operator==(const Video& another) const;

    ~Video();

    /**
     * Set callbacks and private data to render decoded video to a custom
     * area in memory. Use Video::setFormat() or Video::setFormatCallbacks()
     * to configure the decoded format.
     *
     * \param lock  callback to lock video memory (must not be NULL)
     *
     * \param unlock  callback to unlock video memory (or NULL if not needed)
     *
     * \param display  callback to display video (or NULL if not needed)
     *
     * \param opaque  private pointer for the three callbacks (as first
     * parameter)
     *
     * \version LibVLC 1.1.1 or later
     */
    void setCallbacks(libvlc_video_lock_cb lock, libvlc_video_unlock_cb unlock, libvlc_video_display_cb display, void * opaque);

    /**
     * Set decoded video chroma and dimensions. This only works in
     * combination with Video::setCallbacks() , and is mutually exclusive
     * with Video::setFormatCallbacks() .
     *
     * \param chroma  a four-characters string identifying the chroma (e.g.
     * "RV32" or "YUYV")
     *
     * \param width  pixel width
     *
     * \param height  pixel height
     *
     * \param pitch  line pitch (in bytes)
     *
     * \version LibVLC 1.1.1 or later
     */
    void setFormat(const std::string& chroma, unsigned width, unsigned height, unsigned pitch);

    /**
     * Set decoded video chroma and dimensions. This only works in
     * combination with Video::setCallbacks() .
     *
     * \param setup  callback to select the video format (cannot be NULL)
     *
     * \param cleanup  callback to release any allocated resources (or NULL)
     *
     * \version LibVLC 2.0.0 or later
     */
    void setFormatCallbacks(libvlc_video_format_cb setup, libvlc_video_cleanup_cb cleanup);

    /**
     * Enable or disable key press events handling, according to the LibVLC
     * hotkeys configuration. By default and for historical reasons, keyboard
     * events are handled by the LibVLC video widget.
     *
     * \note On X11, there can be only one subscriber for key press and mouse
     * click events per window. If your application has subscribed to those
     * events for the X window ID of the video widget, then LibVLC will not
     * be able to handle key presses and mouse clicks in any case.
     *
     * \warning This function is only implemented for X11 and Win32 at the
     * moment.
     *
     * \param on  true to handle key press events, false to ignore them.
     */
    void setKeyInput(unsigned on);

    /**
     * Enable or disable mouse click events handling. By default, those
     * events are handled. This is needed for DVD menus to work, as well as a
     * few video filters such as "puzzle".
     *
     * \see Video::setKeyInput() .
     *
     * \warning This function is only implemented for X11 and Win32 at the
     * moment.
     *
     * \param on  true to handle mouse click events, false to ignore them.
     */
    void setMouseInput(unsigned on);

    /**
     * Get the pixel dimensions of a video.
     *
     * \param num  number of the video (starting from, and most commonly 0)
     *
     * \param px  pointer to get the pixel width [OUT]
     *
     * \param py  pointer to get the pixel height [OUT]
     *
     * \return 0 on success, -1 if the specified video does not exist
     */
    int size(unsigned num, unsigned * px, unsigned * py);

    /**
     * Get the mouse pointer coordinates over a video. Coordinates are
     * expressed in terms of the decoded video resolution, in terms of pixels
     * on the screen/viewport (to get the latter, you can query your
     * windowing system directly).
     *
     * Either of the coordinates may be negative or larger than the
     * corresponding dimension of the video, if the cursor is outside the
     * rendering area.
     *
     * \warning The coordinates may be out-of-date if the pointer is not
     * located on the video rendering area. LibVLC does not track the pointer
     * if it is outside of the video widget.
     *
     * \note LibVLC does not support multiple pointers (it does of course
     * support multiple input devices sharing the same pointer) at the
     * moment.
     *
     * \param num  number of the video (starting from, and most commonly 0)
     *
     * \param px  pointer to get the abscissa [OUT]
     *
     * \param py  pointer to get the ordinate [OUT]
     *
     * \return 0 on success, -1 if the specified video does not exist
     */
    int cursor(unsigned num, int * px, int * py);

    /**
     * Get the current video scaling factor. See also Video::setScale() .
     *
     * \return the currently configured zoom factor, or 0. if the video is
     * set to fit to the output window/drawable automatically.
     */
    float scale();

    /**
     * Set the video scaling factor. That is the ratio of the number of
     * pixels on screen to the number of pixels in the original decoded video
     * in each dimension. Zero is a special value; it will adjust the video
     * to the output window/drawable (in windowed mode) or the entire screen.
     *
     * Note that not all video outputs support scaling.
     *
     * \param f_factor  the scaling factor, or zero
     */
    void setScale(float f_factor);

    /**
     * Get current video aspect ratio.
     *
     * \return the video aspect ratio or NULL if unspecified (the result must
     * be released with free() or libvlc_free() ).
     */
    std::string aspectRatio();

    /**
     * Set new video aspect ratio.
     *
     * \param psz_aspect  new video aspect-ratio or NULL to reset to default
     *
     * \note Invalid aspect ratios are ignored.
     */
    void setAspectRatio(const std::string& psz_aspect);

    /**
     * Get current video subtitle.
     *
     * \return the video subtitle selected, or -1 if none
     */
    int spu();

    /**
     * Get the number of available video subtitles.
     *
     * \return the number of available video subtitles
     */
    int spuCount();

    /**
     * Get the description of available video subtitles.
     *
     * \return list containing description of available video subtitles
     */
    std::list<TrackDescription> spuDescription();

    /**
     * Set new video subtitle.
     *
     * \param i_spu  video subtitle track to select (i_id from track
     * description)
     *
     * \return 0 on success, -1 if out of range
     */
    int setSpu(int i_spu);

    /**
     * Set new video subtitle file.
     *
     * \param psz_subtitle  new video subtitle file
     *
     * \return the success status (boolean)
     */
    int setSubtitleFile(const std::string& psz_subtitle);

    /**
     * Get the current subtitle delay. Positive values means subtitles are
     * being displayed later, negative values earlier.
     *
     * \return time (in microseconds) the display of subtitles is being
     * delayed
     *
     * \version LibVLC 2.0.0 or later
     */
    int64_t spuDelay();

    /**
     * Set the subtitle delay. This affects the timing of when the subtitle
     * will be displayed. Positive values result in subtitles being displayed
     * later, while negative values will result in subtitles being displayed
     * earlier.
     *
     * The subtitle delay will be reset to zero each time the media changes.
     *
     * \param i_delay  time (in microseconds) the display of subtitles should
     * be delayed
     *
     * \return 0 on success, -1 on error
     *
     * \version LibVLC 2.0.0 or later
     */
    int setSpuDelay(int64_t i_delay);

    /**
     * Get the description of available titles.
     *
     * \return list containing description of available titles
     */
    std::list<TrackDescription> titleDescription();

    /**
     * Get the description of available chapters for specific title.
     *
     * \param i_title  selected title
     *
     * \return list containing description of available chapter for title
     * i_title
     */
    std::list<TrackDescription> chapterDescription(int i_title);

    /**
     * Get current crop filter geometry.
     *
     * \return the crop filter geometry or NULL if unset
     */
    std::string cropGeometry();

    /**
     * Set new crop filter geometry.
     *
     * \param psz_geometry  new crop filter geometry (NULL to unset)
     */
    void setCropGeometry(const std::string& psz_geometry);

    /**
     * Get current teletext page requested.
     *
     * \return the current teletext page requested.
     */
    int teletext();

    /**
     * Set new teletext page to retrieve.
     *
     * \param i_page  teletex page number requested
     */
    void setTeletext(int i_page);

    /**
     * Get number of available video tracks.
     *
     * \return the number of available video tracks (int)
     */
    int trackCount();

    /**
     * Get the description of available video tracks.
     *
     * \return list with description of available video tracks, or NULL on
     * error
     */
    std::list<TrackDescription> trackDescription();

    /**
     * Get current video track.
     *
     * \return the video track ID (int) or -1 if no active input
     */
    int track();

    /**
     * Set video track.
     *
     * \param i_track  the track ID (i_id field from track description)
     *
     * \return 0 on success, -1 if out of range
     */
    int setTrack(int i_track);

    /**
     * Take a snapshot of the current video window.
     *
     * If i_width AND i_height is 0, original size is used. If i_width XOR
     * i_height is 0, original aspect-ratio is preserved.
     *
     * \param num  number of video output (typically 0 for the first/only
     * one)
     *
     * \param psz_filepath  the path where to save the screenshot to
     *
     * \param i_width  the snapshot's width
     *
     * \param i_height  the snapshot's height
     *
     * \return 0 on success, -1 if the video was not found
     */
    int takeSnapshot(unsigned num, const std::string& psz_filepath, unsigned int i_width, unsigned int i_height);

    /**
     * Enable or disable deinterlace filter
     *
     * \param psz_mode  type of deinterlace filter, NULL to disable
     */
    void setDeinterlace(const std::string& psz_mode);

    /**
     * Get an integer marquee option value
     *
     * \param option  marq option to get
     *
     * \see libvlc_video_marquee_int_option_t
     */
    int marqueeInt(unsigned option);

    /**
     * Get a string marquee option value
     *
     * \param option  marq option to get
     *
     * \see libvlc_video_marquee_string_option_t
     */
    std::string marqueeString(unsigned option);

    /**
     * Enable, disable or set an integer marquee option
     *
     * Setting libvlc_marquee_Enable has the side effect of enabling (arg !0)
     * or disabling (arg 0) the marq filter.
     *
     * \param option  marq option to set
     *
     * \see libvlc_video_marquee_int_option_t
     *
     * \param i_val  marq option value
     */
    void setMarqueeInt(unsigned option, int i_val);

    /**
     * Set a marquee string option
     *
     * \param option  marq option to set
     *
     * \see libvlc_video_marquee_string_option_t
     *
     * \param psz_text  marq option value
     */
    void setMarqueeString(unsigned option, const std::string& psz_text);

    /**
     * Get integer logo option.
     *
     * \param option  logo option to get, values of
     * libvlc_video_logo_option_t
     */
    int logoInt(unsigned option);

    /**
     * Set logo option as integer. Options that take a different type value
     * are ignored. Passing libvlc_logo_enable as option value has the side
     * effect of starting (arg !0) or stopping (arg 0) the logo filter.
     *
     * \param option  logo option to set, values of
     * libvlc_video_logo_option_t
     *
     * \param value  logo option value
     */
    void setLogoInt(unsigned option, int value);

    /**
     * Set logo option as string. Options that take a different type value
     * are ignored.
     *
     * \param option  logo option to set, values of
     * libvlc_video_logo_option_t
     *
     * \param psz_value  logo option value
     */
    void setLogoString(unsigned option, const std::string& psz_value);

    /**
     * Get integer adjust option.
     *
     * \param option  adjust option to get, values of
     * libvlc_video_adjust_option_t
     *
     * \version LibVLC 1.1.1 and later.
     */
    int adjustInt(unsigned option);

    /**
     * Set adjust option as integer. Options that take a different type value
     * are ignored. Passing libvlc_adjust_enable as option value has the side
     * effect of starting (arg !0) or stopping (arg 0) the adjust filter.
     *
     * \param option  adust option to set, values of
     * libvlc_video_adjust_option_t
     *
     * \param value  adjust option value
     *
     * \version LibVLC 1.1.1 and later.
     */
    void setAdjustInt(unsigned option, int value);

    /**
     * Get float adjust option.
     *
     * \param option  adjust option to get, values of
     * libvlc_video_adjust_option_t
     *
     * \version LibVLC 1.1.1 and later.
     */
    float adjustFloat(unsigned option);

    /**
     * Set adjust option as float. Options that take a different type value
     * are ignored.
     *
     * \param option  adust option to set, values of
     * libvlc_video_adjust_option_t
     *
     * \param value  adjust option value
     *
     * \version LibVLC 1.1.1 and later.
     */
    void setAdjustFloat(unsigned option, float value);

private:
    /**
     */
    void retain();

    /**
     */
    void release();


    libvlc_media_player_t* m_obj;
};

} // namespace VLC

#endif

