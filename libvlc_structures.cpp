/*****************************************************************************
 * libvlc_structures.cpp: LibVLC++ structures impl
 *****************************************************************************
 * Copyright Â© 2014 the VideoLAN team
 *
 * Authors: Alexey Sokolov <alexey@alexeysokolov.co.cc>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
 *****************************************************************************/

/* This file is autogenerated */


#include <vlc.hpp>
namespace VLC {

const std::string& ModuleDescription::name() const
{
    return m_name;
}

const std::string& ModuleDescription::shortname() const
{
    return m_shortname;
}

const std::string& ModuleDescription::longname() const
{
    return m_longname;
}

const std::string& ModuleDescription::help() const
{
    return m_help;
}

std::list<ModuleDescription> ModuleDescription::makeList(libvlc_module_description_t* head) 
{
    std::list<ModuleDescription> result;
    if ( head == NULL )
        return result;
    libvlc_module_description_t* current = head;
    while (current) 
    {
        result.push_back(ModuleDescription(current));
        current = current->p_next;
    }
    return result;
}

ModuleDescription::ModuleDescription(libvlc_module_description_t* c) 
{
    m_name = c->psz_name ? c->psz_name : "";
    m_shortname = c->psz_shortname ? c->psz_shortname : "";
    m_longname = c->psz_longname ? c->psz_longname : "";
    m_help = c->psz_help ? c->psz_help : "";
}

uint32_t MediaTrackInfo::codec() const
{
    return m_codec;
}

int MediaTrackInfo::id() const
{
    return m_id;
}

libvlc_track_type_t MediaTrackInfo::type() const
{
    return m_type;
}

int MediaTrackInfo::profile() const
{
    return m_profile;
}

int MediaTrackInfo::level() const
{
    return m_level;
}

unsigned MediaTrackInfo::channels() const
{
    return m_channels;
}

unsigned MediaTrackInfo::rate() const
{
    return m_rate;
}

unsigned MediaTrackInfo::height() const
{
    return m_height;
}

unsigned MediaTrackInfo::width() const
{
    return m_width;
}

MediaTrackInfo::MediaTrackInfo(libvlc_media_track_info_t* c) 
{
    m_codec = c->i_codec;
    m_id = c->i_id;
    m_type = c->i_type;
    m_profile = c->i_profile;
    m_level = c->i_level;
    m_channels = c->u.audio.i_channels;
    m_rate = c->u.audio.i_rate;
    m_height = c->u.video.i_height;
    m_width = c->u.video.i_width;
}

const std::string& AudioOutputDescription::name() const
{
    return m_name;
}

const std::string& AudioOutputDescription::description() const
{
    return m_description;
}

std::list<AudioOutputDescription> AudioOutputDescription::makeList(libvlc_audio_output_t* head) 
{
    std::list<AudioOutputDescription> result;
    if ( head == NULL )
        return result;
    libvlc_audio_output_t* current = head;
    while (current) 
    {
        result.push_back(AudioOutputDescription(current));
        current = current->p_next;
    }
    return result;
}

AudioOutputDescription::AudioOutputDescription(libvlc_audio_output_t* c) 
{
    m_name = c->psz_name ? c->psz_name : "";
    m_description = c->psz_description ? c->psz_description : "";
}

int TrackDescription::id() const
{
    return m_id;
}

const std::string& TrackDescription::name() const
{
    return m_name;
}

std::list<TrackDescription> TrackDescription::makeList(libvlc_track_description_t* head) 
{
    std::list<TrackDescription> result;
    if ( head == NULL )
        return result;
    libvlc_track_description_t* current = head;
    while (current) 
    {
        result.push_back(TrackDescription(current));
        current = current->p_next;
    }
    return result;
}

TrackDescription::TrackDescription(libvlc_track_description_t* c) 
{
    m_id = c->i_id;
    m_name = c->psz_name ? c->psz_name : "";
}

} // namespace VLC
